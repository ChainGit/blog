---
title: 为什么计算机存储负整数为反码+1
date: 2016/10/28
categories:
- 学习
tags:
- 学习
- 知识点
---

为什么计算机存储负整数为反码+1
============================
在学习计算机基础时，数值存储在计算机中__均是补码形式__，正整数在计算机存储是原封不动的，原来什么样，存储也是什么样，也就是说__补码=原码=反码__；而负整数却是__补码=反码+1__，反码为原码的除符号位均取反。那么为什么负整数要这样存储？

## 负整数的存储
首先看两个正整数相加，比如 7 + 3 ，计算机以补码形式存储和计算。

效果如下：

```java
  ‭0...0111
+ ‭0...0011‬
----------
 ‭ 0...1010‬
```

可以看到第一位符号位均为0，计算结果也正确，满足 7 + 3 = 10。

接在我们在算 7 - 3 ，计算机中不能直接做减法运算，只能做加法运算（为什么？因为电路上加法器好做，具体可以移步[百度百科](https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%99%A8)）。
实际运算其实是 7 + (-3)。如果 -3 不使用__补码=反码+1__，而是和正数一样，那会怎么样呢？

效果如下：

```java
  0...0111
+ 1...0011
----------
  1...1010
```

可以看到计算结果为 -10，计算结果显然不正确。应该为 7 + (-3) = 4。

下面将负整数 -3 取反，结果如下(WORD)：

```java
~ 1000 0000 0000 0011
---------------------
  ‭1111 1111 1111 1100‬
```

此时的反码和 7 运算的结果呢？
 
```java
  0000 0000 0000 0111
+ 1111 1111 1111 1100‬
---------------------
  0000 0000 0000 0011
```

运算结果为 3 ，这显然与正确结果有出入，要是再加上一就对了。
  
再将反码+1，得到补码：

```java
  1111 1111 1111 1100‬
+ 0000 0000 0000 0001
---------------------
  1111 1111 1111 1101
```

此时将补码与 7 运算，得到结果：

```java
  0000 0000 0000 0111
+ 1111 1111 1111 1101
---------------------
  0000 0000 0000 0100
```

运算结果为 4 ，这个和 7 - 3 = 7 + (-3) = 4 的结果是一致的。

因此，计算机中负整数的存储为__补码 = 反码 + 1__。

## 特殊数字：零

WORD下，+0的存储如下：

```java
+0的原码：0000 0000 0000 0000
+0的反码：0000 0000 0000 0000
+0的补码：0000 0000 0000 0000
```

-0的存储如下：

```java
-0的原码：1000 0000 0000 0000
-0的反码：1111 1111 1111 1111
-0的补码：0000 0000 0000 0000
```

在Eclipse中测试一下：

```java
@Test
public void test4() {
  int a = 0;
  int b = -0;
  System.out.println(Integer.toBinaryString(a));
  System.out.println(Integer.toBinaryString(b));
  System.out.println(a);
  System.out.println(b);
}
```

结果：
> 0
0
0
0

由此可以看出，+0和-0在计算机中存储一样，计算机中没有+0和-0的概念，只有0。另外，也可以看出，-0的存储的符号位为0，哈哈。